#include "dms055a.h"
#include "remoter.h"
#include "math.h"
#include "string.h"
#include "timer.h"

#define MAX_ROADANGLE 12.3
u8 DMS055A_Buf[DMS055A_Buf_Len];

void DMS055A_Init(u32 baudrate)
{
    GPIO_InitTypeDef			GPIO_InitStructure;
    USART_InitTypeDef			USART_InitStructure;
    DMA_InitTypeDef				DMA_InitStructure;
    NVIC_InitTypeDef			NVIC_InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2,ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4,ENABLE);

	#if AUTO_RXTX_485 == 0 //不自动收发，手动配置为发送模式，PD7拉高，控制转向电机
	//PD7 收发控制引脚
	GPIO_InitStructure.GPIO_Pin=GPIO_Pin_7; 
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; 
    GPIO_Init(GPIOD,&GPIO_InitStructure);
	GPIO_SetBits(GPIOD,GPIO_Pin_7);	
	
#endif
	
    //DMS055A_TX -> UART4_TX -> PC.10
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOC,&GPIO_InitStructure);

    //DMS055A_RX -> UART4_RX -> PC.11
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOC,&GPIO_InitStructure);

    //USART 初始化设置
    USART_InitStructure.USART_BaudRate = baudrate;//串口波特率
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
    USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
    USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
    USART_Init(UART4,&USART_InitStructure); //初始化串口4

    USART_Cmd(UART4,ENABLE);						//使能串口4
    USART_DMACmd(UART4,USART_DMAReq_Rx,ENABLE);	//使能串口4_DMA传输

    //UART4 NVIC 配置
    NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3;	//抢占优先级3
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		//子优先级1
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
    NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器

    USART_ClearFlag(UART4,USART_FLAG_IDLE);		//清除串口4空闲中断标志位
    USART_ITConfig(UART4,USART_IT_IDLE,ENABLE);	//开启串口4空闲中断

    DMA_InitStructure.DMA_MemoryBaseAddr = (u32)DMS055A_Buf;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&UART4->DR;
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_BufferSize = DMS055A_Buf_MaxLen;
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_Init(DMA2_Channel3,&DMA_InitStructure);

    DMA_ClearFlag(DMA2_FLAG_TC3);
    DMA_Cmd(DMA2_Channel3,ENABLE);
}
/*
*********************************************************************
* @  name :DMS055A_SendData
* @  func :向转向驱动器发送消息
* @ prama :	*s:需要发送的消息	len:消息长度
* @retval :无
*********************************************************************
* @attention :转向驱动器接到串口4
*********************************************************************
*/
void DMS055A_SendData(u8 *s,u8 len)
{
    while(len--)
    {
        while(USART_GetFlagStatus(UART4,USART_FLAG_TC )==RESET);
        USART_SendData(UART4,*s);
        s++;
    }
}

/*
*********************************************************************
* @  name :Get_DMS055A_Data
* @  func :解析转向驱动器应答消息
* @ prama : *DMS055A_info:解析后数据存放结构体	buf:串口接收到的缓冲区
* @retval : 无
*********************************************************************
* @attention :
*********************************************************************
*/
u32 G_currentPulse;
void Get_DMS055A_Data(DMS055A_info_t *DMS055A_info,u8 *buf)
{	
	u16 DataHigh;
	u16 DataLow;
	u16 crc_data;
	u16 CRC_ata;
    DMS055A_info->DevAddr = buf[0];
    DMS055A_info->FunCode = buf[1];	
	
	DMS055A_info->CRCdata = (buf[7]<<8)|buf[8];//读取校验位值大小
    CRC_ata = DMS055A_info->CRCdata;
	crc_data = DMS055A_CRC16(buf,7);//校验位生成

    if(DMS055A_info->FunCode==0x03 && CRC_ata == crc_data)//485读取数据时从机应答
    {
        DMS055A_info->DataLen = buf[2];
		DataHigh= (buf[5]<<8)|buf[6]; 
		DataLow = (buf[3]<<8)|buf[4];
		
		DMS055A_info->CurrentPos = -~((DataHigh<<16)|DataLow - 1);//无符号转换为有符号
    }
}

//设置前轮转角值
float angle_err;
void setRoadWheelAngle(float angle)
{
#if (STEER_CONTROL_MODE  == STEER_CONTROL_INCREMENT)
	angle_err = angle - g_roadwheelAngle;
	if(fabs(angle_err) < 0.1)
		angle_err = 0.0;
	DMS055A_SendIncrement(angle_err*500);
	
#elif (STEER_CONTROL_MODE  == STEER_CONTROL_POSITION_AND_INCREMENT)
	angle_err = angle - g_roadwheelAngle;
	if(fabs(angle_err) < 0.5)
		angle_err = 0.0;
	
	DMS055A_SendPosition(DMS055A_info.CurrentPos + angle_err*75.57*REDUCER_TRANSMISSION_RATIO);//
#else //原始位置控制模式(根据电机上电时的相对位置)
	float motorAngle =  (angle)*19.0/26; //电机输出轴角度
	setMotorAngle(motorAngle);
#endif
}

//设置转向电机输出轴角度值(上电默认位置为0度)
//angle 电机输出轴角度
void setMotorAngle(float angle)
{
	//将角度转换为脉冲数，通过传动比进行计算
	DMS055A_SendPosition(angle * 7110.11); //4000*64/360
}


/*@brief 增量式控制转向电机
* @prama :Target: 脉冲个数
*/
void DMS055A_SendIncrement(int Target)
{
	u8  modbus_data[13] = {0x01,0x10,0x00,0xC,0x00,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00};
	u8  PU24_31,PU16_23,PU8_15,PU0_7;
	u16 crc_data;
	
	/*负脉冲数转换成32位16进制无符号脉冲数*/
    if(Target<0)
    {
        Target = 0x7FFFFFFF+(Target+1);
        PU24_31 = (Target/(256*65536))+0x80;
    }
    else
    {
        PU24_31 =(Target/(256*65536));
    }
    PU16_23 = (Target/65536)%256;
    PU8_15 = (Target/256)%256;
    PU0_7 = Target%256;

    /*将转换好的脉冲数放入数组中*/
    modbus_data[7] = PU8_15;
    modbus_data[8] = PU0_7;
    modbus_data[9] = PU24_31;
    modbus_data[10] = PU16_23;
	

	crc_data = DMS055A_CRC16(modbus_data,11);

    modbus_data[11] = crc_data/256%256;
    modbus_data[12] = crc_data%256;

    /*将数据包发送给前轮驱动器*/
    DMS055A_SendData(modbus_data,13);
}

/*
*********************************************************************
* @  name :DMS055A_SendPosition
* @  func :控制前轮驱动电机至目标位置（绝对位置）
* @ prama :Target:目标位置(脉冲数)
* @retval :无
*********************************************************************
* @attention :遥控传过来的为有符号数，需要转换成无符号数通过串口发送
*********************************************************************
*/
int steerMotorPulseNum;
void DMS055A_SendPosition(int Target)
{
    u8  modbus_data[13] = {0x01,0x10,0x00,0x16,0x00,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00};
    u8  PU24_31,PU16_23,PU8_15,PU0_7;
    u16 crc_data;
	int sumTarget=0;
	const u8 bufLen = 10;
	static u8 bufIndex = 0;
	static int buf[bufLen];
	buf[bufIndex] = Target;
	bufIndex = (bufIndex+1) % bufLen;
	
	for(u8 i=0;i<bufLen;++i)
		sumTarget+=buf[i];
	
	steerMotorPulseNum = sumTarget/bufLen;
	
    /*负脉冲数转换成32位16进制无符号脉冲数*/
    if(Target<0)
    {
        Target = 0x7FFFFFFF+(Target+1);
        PU24_31 = (Target/(256*65536))+0x80;
    }
    else if(Target==0)
        Target = 1;
    else
    {
        PU24_31 =(Target/(256*65536));
    }
    PU16_23 = (Target/65536)%256;
    PU8_15 = (Target/256)%256;
    PU0_7 = Target%256;

    /*将转换好的脉冲数放入数组中*/
    modbus_data[7] = PU8_15;
    modbus_data[8] = PU0_7;
    modbus_data[9] = PU24_31;
    modbus_data[10] = PU16_23;

    crc_data = DMS055A_CRC16(modbus_data,11);

    modbus_data[11] = crc_data/256%256;
    modbus_data[12] = crc_data%256;

    /*将数据包发送给前轮驱动器*/
    DMS055A_SendData(modbus_data,13);
}

/*
*********************************************************************
* @  name :DMS055A_FindEN
* @  func :前轮驱动器找原点位置
* @ prama :无
* @retval :无
*********************************************************************
* @attention :向0x19寄存器写2，驱动器找EN信号，若电流值超过阈值，则换向找EN信号
*********************************************************************
*/
void DMS055A_FindEN(void)
{
    u8  FindEN[8] = {0x01,0x06,0x00,0x19,0x00,0x02,0x00,0x00};
    u16 crc_data;

    crc_data = DMS055A_CRC16(FindEN,6);

    FindEN[6] = crc_data/256%256;
    FindEN[7] = crc_data%256;
    DMS055A_SendData(FindEN,8);
}

/*
*********************************************************************
* @  name :DMS055A_ReadCurrent
* @  func :读取转向驱动器的电流值
* @ prama :无
* @retval :无
*********************************************************************
* @attention :
*********************************************************************
*/
void DMS055A_ReadCurrent(void)
{
    u8  ReadCurrent[8] = {0x01,0x03,0x00,0x0F,0x00,0x01,0x00,0x00};
    u16 crc_data;

    crc_data = DMS055A_CRC16(ReadCurrent,6);

    ReadCurrent[6] = crc_data/256%256;
    ReadCurrent[7] = crc_data%256;

    DMS055A_SendData(ReadCurrent,8);
}

//请求电机位置
void DMS055A_ReadPosition(void)
{
    u8 ReadPos[8] = {0x01,0x03,0x00,0x16,0x00,0x02,0x25,0xCF};
	u16 crc_data;

    crc_data = DMS055A_CRC16(ReadPos,6);

    ReadPos[6] = crc_data/256%256;
    ReadPos[7] = crc_data%256;

    DMS055A_SendData(ReadPos,8);
}

int db_fullDir;
float db_adjustVoltage;
float g_angleSensorVoltage = 0.0;
//根据转角传感器电压值计算前轮转角值
float getRoadWheelAngle()
{
	static int   voltageFullDir = 0; //电压溢出方向，默认未溢出
	static float lastSensorVoltage = 0.0;
	static u8 first = 1;
	
	float k = (ANGLE_SENSOR_MAX_VOLTAGE-ANGLE_SENSOR_MID_VOLTAGE)/(ROADWHEEL_ANGLE_MAX_DEG-0.0);
	g_angleSensorVoltage = Get_Adc_Average(ADC_Channel_13,10) * 3.3 / 4095.0;
	
	if(first)
	{
		first = 0;
		lastSensorVoltage = g_angleSensorVoltage;
	}
	
	
	//当转角传感器旋转超出360度时进行超出计数补偿，需保证应用场景的采集频率高于跳变频率
	float adjustedVoltage = g_angleSensorVoltage;  //调整后的电压值，当超出传感器量程后进行调整
	
	//上次电压位于上游且当前电压位于下游，表明传感器正向溢出
	if(lastSensorVoltage > 2.5 && g_angleSensorVoltage < 0.8)
	{
		if(voltageFullDir == 0) //如当前无溢出标志，则标记为正向溢出
			voltageFullDir = 1;
		else if(voltageFullDir == -1)//若当前为反向溢出，则标记为未溢出
			voltageFullDir = 0;
		//若处理多圈溢出场景，可使用 voltageFullDir++
	}
	//上次电压位于下游且当前电压位于上游，表明传感器反向溢出
	else if(lastSensorVoltage < 0.8 && g_angleSensorVoltage > 2.5)
	{
		if(voltageFullDir == 0) //同上
			voltageFullDir = -1;
		else if(voltageFullDir == 1)//同上
			voltageFullDir = 0;
		//若应用于多圈溢出场景，可使用 voltageFullDir--
	}

	adjustedVoltage = g_angleSensorVoltage + voltageFullDir * 3.3;
	db_adjustVoltage = 	adjustedVoltage;
	db_fullDir = voltageFullDir;
	lastSensorVoltage = g_angleSensorVoltage;
	
	//如电压增大方向与角度增大方向不一致，返回值需添加负号
	return -((adjustedVoltage - ANGLE_SENSOR_MID_VOLTAGE)/k); 
}


/*
*********************************************************************
* @  name :CRC16
* @  func :DMS-055A驱动器CRC校验
* @ prama :*puchMsg：要进行CRC 校验的消息
			usDataLen：消息中字节数
* @retval :CRC校验码
*********************************************************************
* @attention :
*********************************************************************
*/
unsigned short DMS055A_CRC16(unsigned char *puchMsg,unsigned short usDataLen)
{
    unsigned char uchCRCHi = 0xFF ; /* 高CRC 字节初始化*/
    unsigned char uchCRCLo = 0xFF ; /* 低CRC 字节初始化*/
    unsigned  uIndex; /* CRC 循环中的索引*/

    while (usDataLen--) /* 传输消息缓冲区*/
    {
        uIndex = uchCRCHi ^ *puchMsg++; /* 计算CRC */
        uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex];
        uchCRCLo = auchCRCLo[uIndex];
    }
    return (uchCRCHi<<8|uchCRCLo);
}


DMS055A_info_t  DMS055A_info;
u16 UART4_LEN;
void UART4_IRQHandler(void)
{
    if(USART_GetITStatus(UART4,USART_IT_IDLE)!=RESET)
    {
        (void)UART4->SR;
        (void)UART4->DR;
		DMA_Cmd(DMA2_Channel3,DISABLE);
			UART4_LEN = DMS055A_Buf_Len-DMA_GetCurrDataCounter(DMA2_Channel3);
        if(DMS055A_Buf[0]==0x01) //设备地址(前轮转向驱动器)
        {
            Get_DMS055A_Data(&DMS055A_info,DMS055A_Buf);
        }
        DMA_SetCurrDataCounter(DMA2_Channel3,DMS055A_Buf_MaxLen);
        DMA_Cmd(DMA2_Channel3,ENABLE);
    }
}

